import type { Request, Response } from "express";
import type { Subscription, SubscriptionDTO } from "@/model/Subscription.js";
import { randomUUID } from "crypto";
import { eq, and } from "drizzle-orm";

import db from "@/db/db.js";
import { subscriptions } from "@/db/schemas/schema.js";


export const getSubscriptions = async (req: Request, res: Response) => {
  try {
    const subscriptionsList = await db.select().from(subscriptions).where(and(
      eq(subscriptions.isActive, 1),
      eq(subscriptions.userId, req.user.id) // Assuming req.user.id contains the authenticated user's ID
    ));
    res.status(200).json(subscriptionsList);
  } catch (error) {
    console.error('Error fetching subscriptions:', error);
    res.status(500).json({ message: 'Internal Server Error' });
  }
}

export const getSubscriptionsById = async (req: Request, res: Response) => {
  const { id } = req.params;
  console.log(`Fetching subscription with ID: ${id}`);

  try {
    const subscription = await db.select().from(subscriptions).where(and(
      eq(subscriptions.userId, req.user.id), // Assuming req.user.id contains the authenticated user's ID
      eq(subscriptions.id, id!) // Filter by subscription ID
    ));

    if (!subscription) {
      res.status(404).json({ message: 'Subscription not found' });
      return;
    }

    res.status(200).json(subscription);
  } catch (error) {
    console.error('Error fetching subscription:', error);
    res.status(500).json({ message: 'Internal Server Error' });
  }
}

export const createSubscription = async (req: Request, res: Response) => {
  const { name, price, currency, billingCycle } = req.body;
  const userId = req.user.id; // Assuming req.user.id contains the authenticated user's ID

  try {
    // Simulate creating a new subscription
    let nextBillingDate: number;
    if (billingCycle === 'monthly') {
      nextBillingDate = Date.now() + 30 * 24 * 60 * 60 * 1000; // Set next billing date to 30 days from now
    } else if (billingCycle === 'yearly') {
      nextBillingDate = Date.now() + 365 * 24 * 60 * 60 * 1000; // Set next billing date to 1 year from now
    } else if (billingCycle === 'weekly') {
      nextBillingDate = Date.now() + 7 * 24 * 60 * 60 * 1000; // Set next billing date to 7 days from now
    } else {
      res.status(400).json({ message: 'Invalid billing cycle' });
      return;
    }
    const newSubscription: typeof subscriptions.$inferInsert = {
      id: randomUUID(), // In a real application, this would be generated by the database
      name,
      price,
      userId,
      currency,
      billingCycle,
      nextBillingDate, // Set next billing date based on billing cycle
      isActive: 1, // 1 means active
      createdAt: Date.now(),
      updatedAt: Date.now()
    };

    // Insert the new subscription into the database
    await db.insert(subscriptions).values(newSubscription).returning();

    res.status(201).json(newSubscription);
  } catch (error) {
    console.error('Error creating subscription:', error);
    res.status(500).json({ message: 'Internal Server Error' });
  }
}

export const updateSubscription = async (req: Request, res: Response) => {
  const { id } = req.params;
  const { name, price, currency, billingCycle, isActive }: SubscriptionDTO = req.body;

  try {
    // Simulate finding the subscription to update
    const subscriptionToUpdate = await db.select().from(subscriptions).where(eq(subscriptions.id, id!)).then((row) => row[0])

    if (!subscriptionToUpdate) {
      res.status(404).json({ message: 'Subscription not found' });
      return;
    }

    // Replace the old subscription with the updated one
    const updatedSubscription = await db.update(subscriptions).set({
      name: name ?? subscriptionToUpdate.name,
      price: price ?? subscriptionToUpdate.price,
      currency: currency ?? subscriptionToUpdate.currency,
      billingCycle: billingCycle ?? subscriptionToUpdate.billingCycle,
      isActive: isActive !== undefined ? (isActive ? 1 : 0) : subscriptionToUpdate.isActive,
      updatedAt: Date.now() // Update the timestamp
    }).returning().where(and(eq(subscriptions.id, id!), eq(subscriptions.userId, req.user.id))).then((row) => row[0]);

    res.status(200).json(updatedSubscription);
  } catch (error) {
    console.error('Error updating subscription:', error);
    res.status(500).json({ message: 'Internal Server Error' });
  }
}

export const deleteSubscription = async (req: Request, res: Response) => {
  const { id } = req.params;

  try {
    // Simulate deleting a subscription
    const subsciptions = await db.select().from(subscriptions).where(eq(subscriptions.id, id!));
    if (subsciptions.length === 0) {
      res.status(404).json({ message: 'Subscription not found' });
      return;
    }

    // Mark the subscription as inactive instead of deleting it
    await db.update(subscriptions).set({
      isActive: 0, // Set isActive to 0 to mark it as inactive
      updatedAt: Date.now() // Update the timestamp
    }).where(eq(subscriptions.id, id!));
    
    res.status(204).send(); // No content to return after deletion
  } catch (error) {
    console.error('Error deleting subscription:', error);
    res.status(500).json({ message: 'Internal Server Error' });
  }
}